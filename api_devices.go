/*
Portal API 2.0

2.2.10

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package itportalapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"reflect"
	"strings"
)

// DevicesAPIService DevicesAPI service
type DevicesAPIService service

type ApiCreateDeviceRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	device        *Device
}

func (r ApiCreateDeviceRequest) Authorization(authorization string) ApiCreateDeviceRequest {
	r.authorization = &authorization
	return r
}

// Device object that needs to be added to the portal
func (r ApiCreateDeviceRequest) Device(device Device) ApiCreateDeviceRequest {
	r.device = &device
	return r
}

func (r ApiCreateDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateDeviceExecute(r)
}

/*
CreateDevice Adds a new device to the portal

New device will be added to the portal

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateDeviceRequest
*/
func (a *DevicesAPIService) CreateDevice(ctx context.Context) ApiCreateDeviceRequest {
	return ApiCreateDeviceRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DevicesAPIService) CreateDeviceExecute(r ApiCreateDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.CreateDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.device == nil {
		return nil, reportError("device is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.device
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateDeviceIPRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	deviceId      int64
	iPPatch       *IPPatch
}

func (r ApiCreateDeviceIPRequest) Authorization(authorization string) ApiCreateDeviceIPRequest {
	r.authorization = &authorization
	return r
}

// Device IP object that needs to be added to the portal
func (r ApiCreateDeviceIPRequest) IPPatch(iPPatch IPPatch) ApiCreateDeviceIPRequest {
	r.iPPatch = &iPPatch
	return r
}

func (r ApiCreateDeviceIPRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateDeviceIPExecute(r)
}

/*
CreateDeviceIP Adds a new device IP to the portal

New device IP will be added to the portal

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@return ApiCreateDeviceIPRequest
*/
func (a *DevicesAPIService) CreateDeviceIP(ctx context.Context, deviceId int64) ApiCreateDeviceIPRequest {
	return ApiCreateDeviceIPRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
func (a *DevicesAPIService) CreateDeviceIPExecute(r ApiCreateDeviceIPRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.CreateDeviceIP")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/ips/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.iPPatch == nil {
		return nil, reportError("iPPatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.iPPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateDeviceMUrlRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	deviceId      int64
	mUrl          *MUrl
}

func (r ApiCreateDeviceMUrlRequest) Authorization(authorization string) ApiCreateDeviceMUrlRequest {
	r.authorization = &authorization
	return r
}

// Device Management Url object that needs to be added to the portal
func (r ApiCreateDeviceMUrlRequest) MUrl(mUrl MUrl) ApiCreateDeviceMUrlRequest {
	r.mUrl = &mUrl
	return r
}

func (r ApiCreateDeviceMUrlRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateDeviceMUrlExecute(r)
}

/*
CreateDeviceMUrl Adds a new device Management Url to the portal

New device Management Url will be added to the portal

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@return ApiCreateDeviceMUrlRequest
*/
func (a *DevicesAPIService) CreateDeviceMUrl(ctx context.Context, deviceId int64) ApiCreateDeviceMUrlRequest {
	return ApiCreateDeviceMUrlRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
func (a *DevicesAPIService) CreateDeviceMUrlExecute(r ApiCreateDeviceMUrlRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.CreateDeviceMUrl")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/managementUrls/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.mUrl == nil {
		return nil, reportError("mUrl is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.mUrl
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateDeviceNoteRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	deviceId      int64
	deviceNote    *DeviceNote
}

func (r ApiCreateDeviceNoteRequest) Authorization(authorization string) ApiCreateDeviceNoteRequest {
	r.authorization = &authorization
	return r
}

// Device Note object that needs to be added to the portal
func (r ApiCreateDeviceNoteRequest) DeviceNote(deviceNote DeviceNote) ApiCreateDeviceNoteRequest {
	r.deviceNote = &deviceNote
	return r
}

func (r ApiCreateDeviceNoteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateDeviceNoteExecute(r)
}

/*
CreateDeviceNote Adds a new device Note to the portal

New device Note will be added to the portal

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@return ApiCreateDeviceNoteRequest
*/
func (a *DevicesAPIService) CreateDeviceNote(ctx context.Context, deviceId int64) ApiCreateDeviceNoteRequest {
	return ApiCreateDeviceNoteRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
func (a *DevicesAPIService) CreateDeviceNoteExecute(r ApiCreateDeviceNoteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.CreateDeviceNote")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.deviceNote == nil {
		return nil, reportError("deviceNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.deviceNote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateDeviceSwitchPortRangeRequest struct {
	ctx             context.Context
	ApiService      *DevicesAPIService
	authorization   *string
	deviceId        int64
	switchPortRange *SwitchPortRange
}

func (r ApiCreateDeviceSwitchPortRangeRequest) Authorization(authorization string) ApiCreateDeviceSwitchPortRangeRequest {
	r.authorization = &authorization
	return r
}

// Switch Port Range object that needs to be added to the portal
func (r ApiCreateDeviceSwitchPortRangeRequest) SwitchPortRange(switchPortRange SwitchPortRange) ApiCreateDeviceSwitchPortRangeRequest {
	r.switchPortRange = &switchPortRange
	return r
}

func (r ApiCreateDeviceSwitchPortRangeRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateDeviceSwitchPortRangeExecute(r)
}

/*
CreateDeviceSwitchPortRange Adds a new device switch port range to the portal

New device switch port range will be added to the portal

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@return ApiCreateDeviceSwitchPortRangeRequest
*/
func (a *DevicesAPIService) CreateDeviceSwitchPortRange(ctx context.Context, deviceId int64) ApiCreateDeviceSwitchPortRangeRequest {
	return ApiCreateDeviceSwitchPortRangeRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
func (a *DevicesAPIService) CreateDeviceSwitchPortRangeExecute(r ApiCreateDeviceSwitchPortRangeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.CreateDeviceSwitchPortRange")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/switchPortRanges/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.switchPortRange == nil {
		return nil, reportError("switchPortRange is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.switchPortRange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDeviceByIdRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	deviceId      int64
}

func (r ApiDeleteDeviceByIdRequest) Authorization(authorization string) ApiDeleteDeviceByIdRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteDeviceByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDeviceByIdExecute(r)
}

/*
DeleteDeviceById Deletes a device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@return ApiDeleteDeviceByIdRequest
*/
func (a *DevicesAPIService) DeleteDeviceById(ctx context.Context, deviceId int64) ApiDeleteDeviceByIdRequest {
	return ApiDeleteDeviceByIdRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
func (a *DevicesAPIService) DeleteDeviceByIdExecute(r ApiDeleteDeviceByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.DeleteDeviceById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteManagementURLByIdRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	deviceId      int64
	murlId        int64
}

func (r ApiDeleteManagementURLByIdRequest) Authorization(authorization string) ApiDeleteManagementURLByIdRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteManagementURLByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteManagementURLByIdExecute(r)
}

/*
DeleteManagementURLById Deletes a Management URL

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@param murlId A single device Management Url id.
	@return ApiDeleteManagementURLByIdRequest
*/
func (a *DevicesAPIService) DeleteManagementURLById(ctx context.Context, deviceId int64, murlId int64) ApiDeleteManagementURLByIdRequest {
	return ApiDeleteManagementURLByIdRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
		murlId:     murlId,
	}
}

// Execute executes the request
func (a *DevicesAPIService) DeleteManagementURLByIdExecute(r ApiDeleteManagementURLByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.DeleteManagementURLById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/managementUrls/{murlId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"murlId"+"}", url.PathEscape(parameterValueToString(r.murlId, "murlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSwitchPortRangeByIdRequest struct {
	ctx               context.Context
	ApiService        *DevicesAPIService
	authorization     *string
	deviceId          int64
	switchPortRangeId int64
}

func (r ApiDeleteSwitchPortRangeByIdRequest) Authorization(authorization string) ApiDeleteSwitchPortRangeByIdRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteSwitchPortRangeByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSwitchPortRangeByIdExecute(r)
}

/*
DeleteSwitchPortRangeById Deletes a switch port range

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@param switchPortRangeId A single device switch port range id.
	@return ApiDeleteSwitchPortRangeByIdRequest
*/
func (a *DevicesAPIService) DeleteSwitchPortRangeById(ctx context.Context, deviceId int64, switchPortRangeId int64) ApiDeleteSwitchPortRangeByIdRequest {
	return ApiDeleteSwitchPortRangeByIdRequest{
		ApiService:        a,
		ctx:               ctx,
		deviceId:          deviceId,
		switchPortRangeId: switchPortRangeId,
	}
}

// Execute executes the request
func (a *DevicesAPIService) DeleteSwitchPortRangeByIdExecute(r ApiDeleteSwitchPortRangeByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.DeleteSwitchPortRangeById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/switchPortRanges/{switchPortRangeId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"switchPortRangeId"+"}", url.PathEscape(parameterValueToString(r.switchPortRangeId, "switchPortRangeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetConfigurationFilesByDeviceIdRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	deviceId      int64
	orderBy       *[]string
	limit         *int32
	offset        *int32
	keyValue      *string
}

func (r ApiGetConfigurationFilesByDeviceIdRequest) Authorization(authorization string) ApiGetConfigurationFilesByDeviceIdRequest {
	r.authorization = &authorization
	return r
}

// Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
func (r ApiGetConfigurationFilesByDeviceIdRequest) OrderBy(orderBy []string) ApiGetConfigurationFilesByDeviceIdRequest {
	r.orderBy = &orderBy
	return r
}

// Limit the result set to the specified number of resources.
func (r ApiGetConfigurationFilesByDeviceIdRequest) Limit(limit int32) ApiGetConfigurationFilesByDeviceIdRequest {
	r.limit = &limit
	return r
}

// Skip the specified number of resources in the result set.
func (r ApiGetConfigurationFilesByDeviceIdRequest) Offset(offset int32) ApiGetConfigurationFilesByDeviceIdRequest {
	r.offset = &offset
	return r
}

// Must be specified if using a custom encryption key to encrypt data (found in login form).
func (r ApiGetConfigurationFilesByDeviceIdRequest) KeyValue(keyValue string) ApiGetConfigurationFilesByDeviceIdRequest {
	r.keyValue = &keyValue
	return r
}

func (r ApiGetConfigurationFilesByDeviceIdRequest) Execute() (*ConfigurationFileDataWrapper, *http.Response, error) {
	return r.ApiService.GetConfigurationFilesByDeviceIdExecute(r)
}

/*
GetConfigurationFilesByDeviceId Fetches Configuration files by a single device id

This method fetches a single device configurations files resource.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@return ApiGetConfigurationFilesByDeviceIdRequest
*/
func (a *DevicesAPIService) GetConfigurationFilesByDeviceId(ctx context.Context, deviceId int64) ApiGetConfigurationFilesByDeviceIdRequest {
	return ApiGetConfigurationFilesByDeviceIdRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
//
//	@return ConfigurationFileDataWrapper
func (a *DevicesAPIService) GetConfigurationFilesByDeviceIdExecute(r ApiGetConfigurationFilesByDeviceIdRequest) (*ConfigurationFileDataWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConfigurationFileDataWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.GetConfigurationFilesByDeviceId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/configurationFiles/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.orderBy != nil {
		t := *r.orderBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.keyValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyValue", r.keyValue, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCredentialsByDeviceIdRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	deviceId      int64
}

func (r ApiGetCredentialsByDeviceIdRequest) Authorization(authorization string) ApiGetCredentialsByDeviceIdRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetCredentialsByDeviceIdRequest) Execute() (*Credentials, *http.Response, error) {
	return r.ApiService.GetCredentialsByDeviceIdExecute(r)
}

/*
GetCredentialsByDeviceId Fetches credentials by a single device id

This method fetches a single device credentials resource.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@return ApiGetCredentialsByDeviceIdRequest
*/
func (a *DevicesAPIService) GetCredentialsByDeviceId(ctx context.Context, deviceId int64) ApiGetCredentialsByDeviceIdRequest {
	return ApiGetCredentialsByDeviceIdRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
//
//	@return Credentials
func (a *DevicesAPIService) GetCredentialsByDeviceIdExecute(r ApiGetCredentialsByDeviceIdRequest) (*Credentials, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Credentials
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.GetCredentialsByDeviceId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/credentials/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceByIdRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	deviceId      int64
}

func (r ApiGetDeviceByIdRequest) Authorization(authorization string) ApiGetDeviceByIdRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetDeviceByIdRequest) Execute() (*DeviceDataWrapper, *http.Response, error) {
	return r.ApiService.GetDeviceByIdExecute(r)
}

/*
GetDeviceById Fetches a single device by id

This method fetches a single device resource. It is the canonical URI for any device resource provided by the API.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@return ApiGetDeviceByIdRequest
*/
func (a *DevicesAPIService) GetDeviceById(ctx context.Context, deviceId int64) ApiGetDeviceByIdRequest {
	return ApiGetDeviceByIdRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
//
//	@return DeviceDataWrapper
func (a *DevicesAPIService) GetDeviceByIdExecute(r ApiGetDeviceByIdRequest) (*DeviceDataWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeviceDataWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.GetDeviceById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDevicesRequest struct {
	ctx             context.Context
	ApiService      *DevicesAPIService
	authorization   *string
	name            *string
	nameStartsWith  *string
	typeName        *string
	typeId          *int64
	warrantyExpires *string
	companyId       *string
	company         *string
	siteId          *string
	cabinetId       *string
	facilityId      *string
	installDate     *string
	purchaseDate    *string
	retireDate      *string
	leaseEndDate    *string
	manufacturer    *string
	ipAddress       *string
	macAddress      *string
	imei            *string
	serialNumber    *string
	tag             *string
	inOut           *bool
	deleted         *bool
	modifiedSince   *string
	foreignId       *string
	foreignType     *[]string
	orderBy         *[]string
	limit           *int32
	offset          *int32
	keyValue        *string
}

func (r ApiGetDevicesRequest) Authorization(authorization string) ApiGetDevicesRequest {
	r.authorization = &authorization
	return r
}

// Return only items matching the specified name.
func (r ApiGetDevicesRequest) Name(name string) ApiGetDevicesRequest {
	r.name = &name
	return r
}

// Return items with names that begin with the specified string.
func (r ApiGetDevicesRequest) NameStartsWith(nameStartsWith string) ApiGetDevicesRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Return only items matching the specified type.
func (r ApiGetDevicesRequest) TypeName(typeName string) ApiGetDevicesRequest {
	r.typeName = &typeName
	return r
}

// Return only items matching the specified type id.
func (r ApiGetDevicesRequest) TypeId(typeId int64) ApiGetDevicesRequest {
	r.typeId = &typeId
	return r
}

// Return only items matching specified warranty expiration date.
func (r ApiGetDevicesRequest) WarrantyExpires(warrantyExpires string) ApiGetDevicesRequest {
	r.warrantyExpires = &warrantyExpires
	return r
}

// Return only items matching the specified company id.
func (r ApiGetDevicesRequest) CompanyId(companyId string) ApiGetDevicesRequest {
	r.companyId = &companyId
	return r
}

// Return only items matching the specified company name.
func (r ApiGetDevicesRequest) Company(company string) ApiGetDevicesRequest {
	r.company = &company
	return r
}

// Return only items matching the specified site id.
func (r ApiGetDevicesRequest) SiteId(siteId string) ApiGetDevicesRequest {
	r.siteId = &siteId
	return r
}

// Return only items matching the specified cabinet id.
func (r ApiGetDevicesRequest) CabinetId(cabinetId string) ApiGetDevicesRequest {
	r.cabinetId = &cabinetId
	return r
}

// Return only items matching the specified facility id.
func (r ApiGetDevicesRequest) FacilityId(facilityId string) ApiGetDevicesRequest {
	r.facilityId = &facilityId
	return r
}

// Return only items matching specified install date.
func (r ApiGetDevicesRequest) InstallDate(installDate string) ApiGetDevicesRequest {
	r.installDate = &installDate
	return r
}

// Return only items matching specified purchase date.
func (r ApiGetDevicesRequest) PurchaseDate(purchaseDate string) ApiGetDevicesRequest {
	r.purchaseDate = &purchaseDate
	return r
}

// Return only items matching specified retire date.
func (r ApiGetDevicesRequest) RetireDate(retireDate string) ApiGetDevicesRequest {
	r.retireDate = &retireDate
	return r
}

// Return only items matching specified lease end date.
func (r ApiGetDevicesRequest) LeaseEndDate(leaseEndDate string) ApiGetDevicesRequest {
	r.leaseEndDate = &leaseEndDate
	return r
}

// Return only items matching specified manufacturer.
func (r ApiGetDevicesRequest) Manufacturer(manufacturer string) ApiGetDevicesRequest {
	r.manufacturer = &manufacturer
	return r
}

// Return only items matching specified IP Address.
func (r ApiGetDevicesRequest) IpAddress(ipAddress string) ApiGetDevicesRequest {
	r.ipAddress = &ipAddress
	return r
}

// Return only items matching specified MAC Address.
func (r ApiGetDevicesRequest) MacAddress(macAddress string) ApiGetDevicesRequest {
	r.macAddress = &macAddress
	return r
}

// Return only items matching specified IMEI.
func (r ApiGetDevicesRequest) Imei(imei string) ApiGetDevicesRequest {
	r.imei = &imei
	return r
}

// Return only items matching specified serial number.
func (r ApiGetDevicesRequest) SerialNumber(serialNumber string) ApiGetDevicesRequest {
	r.serialNumber = &serialNumber
	return r
}

// Return only items matching specified tag.
func (r ApiGetDevicesRequest) Tag(tag string) ApiGetDevicesRequest {
	r.tag = &tag
	return r
}

// Return only active/inactive items.
func (r ApiGetDevicesRequest) InOut(inOut bool) ApiGetDevicesRequest {
	r.inOut = &inOut
	return r
}

// Return only deleted items.
func (r ApiGetDevicesRequest) Deleted(deleted bool) ApiGetDevicesRequest {
	r.deleted = &deleted
	return r
}

// Return only items which have been modified since the specified date.
func (r ApiGetDevicesRequest) ModifiedSince(modifiedSince string) ApiGetDevicesRequest {
	r.modifiedSince = &modifiedSince
	return r
}

// Return only items matching the specified foreign company id from synced integration.
func (r ApiGetDevicesRequest) ForeignId(foreignId string) ApiGetDevicesRequest {
	r.foreignId = &foreignId
	return r
}

// Return only items matching the specified foreign type for synced integration. (AutoTask/ConnectWise/ConnectWise configuration as Portal agreement)
func (r ApiGetDevicesRequest) ForeignType(foreignType []string) ApiGetDevicesRequest {
	r.foreignType = &foreignType
	return r
}

// Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
func (r ApiGetDevicesRequest) OrderBy(orderBy []string) ApiGetDevicesRequest {
	r.orderBy = &orderBy
	return r
}

// Limit the result set to the specified number of resources.
func (r ApiGetDevicesRequest) Limit(limit int32) ApiGetDevicesRequest {
	r.limit = &limit
	return r
}

// Skip the specified number of resources in the result set.
func (r ApiGetDevicesRequest) Offset(offset int32) ApiGetDevicesRequest {
	r.offset = &offset
	return r
}

// Must be specified if using a custom encryption key to encrypt data (found in login form).
func (r ApiGetDevicesRequest) KeyValue(keyValue string) ApiGetDevicesRequest {
	r.keyValue = &keyValue
	return r
}

func (r ApiGetDevicesRequest) Execute() (*DeviceDataWrapper, *http.Response, error) {
	return r.ApiService.GetDevicesExecute(r)
}

/*
GetDevices Fetches lists of devices

Fetches lists of portal devices with optional filters. See notes on individual parameters below.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetDevicesRequest
*/
func (a *DevicesAPIService) GetDevices(ctx context.Context) ApiGetDevicesRequest {
	return ApiGetDevicesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DeviceDataWrapper
func (a *DevicesAPIService) GetDevicesExecute(r ApiGetDevicesRequest) (*DeviceDataWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeviceDataWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.GetDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.typeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typeName", r.typeName, "form", "")
	}
	if r.typeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typeId", r.typeId, "form", "")
	}
	if r.warrantyExpires != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "warrantyExpires", r.warrantyExpires, "form", "")
	}
	if r.companyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "form", "")
	}
	if r.company != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "company", r.company, "form", "")
	}
	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	}
	if r.cabinetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cabinetId", r.cabinetId, "form", "")
	}
	if r.facilityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "facilityId", r.facilityId, "form", "")
	}
	if r.installDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "installDate", r.installDate, "form", "")
	}
	if r.purchaseDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseDate", r.purchaseDate, "form", "")
	}
	if r.retireDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retireDate", r.retireDate, "form", "")
	}
	if r.leaseEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "leaseEndDate", r.leaseEndDate, "form", "")
	}
	if r.manufacturer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer", r.manufacturer, "form", "")
	}
	if r.ipAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ipAddress", r.ipAddress, "form", "")
	}
	if r.macAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "macAddress", r.macAddress, "form", "")
	}
	if r.imei != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imei", r.imei, "form", "")
	}
	if r.serialNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", r.serialNumber, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.inOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inOut", r.inOut, "form", "")
	}
	if r.deleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted", r.deleted, "form", "")
	}
	if r.modifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modifiedSince", r.modifiedSince, "form", "")
	}
	if r.foreignId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foreignId", r.foreignId, "form", "")
	}
	if r.foreignType != nil {
		t := *r.foreignType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "foreignType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "foreignType", t, "form", "multi")
		}
	}
	if r.orderBy != nil {
		t := *r.orderBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.keyValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyValue", r.keyValue, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIpsByDeviceIdRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	deviceId      int64
	ipId          *int32
	limit         *int32
	offset        *int32
	keyValue      *string
}

func (r ApiGetIpsByDeviceIdRequest) Authorization(authorization string) ApiGetIpsByDeviceIdRequest {
	r.authorization = &authorization
	return r
}

// Return only items matching specified IP Address ID.
func (r ApiGetIpsByDeviceIdRequest) IpId(ipId int32) ApiGetIpsByDeviceIdRequest {
	r.ipId = &ipId
	return r
}

// Limit the result set to the specified number of resources.
func (r ApiGetIpsByDeviceIdRequest) Limit(limit int32) ApiGetIpsByDeviceIdRequest {
	r.limit = &limit
	return r
}

// Skip the specified number of resources in the result set.
func (r ApiGetIpsByDeviceIdRequest) Offset(offset int32) ApiGetIpsByDeviceIdRequest {
	r.offset = &offset
	return r
}

// Must be specified if using a custom encryption key to encrypt data (found in login form).
func (r ApiGetIpsByDeviceIdRequest) KeyValue(keyValue string) ApiGetIpsByDeviceIdRequest {
	r.keyValue = &keyValue
	return r
}

func (r ApiGetIpsByDeviceIdRequest) Execute() (*IPDataWrapper, *http.Response, error) {
	return r.ApiService.GetIpsByDeviceIdExecute(r)
}

/*
GetIpsByDeviceId Fetches IPs by a single device id

This method fetches a single device IPs resource.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@return ApiGetIpsByDeviceIdRequest
*/
func (a *DevicesAPIService) GetIpsByDeviceId(ctx context.Context, deviceId int64) ApiGetIpsByDeviceIdRequest {
	return ApiGetIpsByDeviceIdRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
//
//	@return IPDataWrapper
func (a *DevicesAPIService) GetIpsByDeviceIdExecute(r ApiGetIpsByDeviceIdRequest) (*IPDataWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IPDataWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.GetIpsByDeviceId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/ips/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.ipId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ipId", r.ipId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.keyValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyValue", r.keyValue, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMUrlsByDeviceIdRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	deviceId      int64
	murlId        *int32
	limit         *int32
	offset        *int32
	keyValue      *string
}

func (r ApiGetMUrlsByDeviceIdRequest) Authorization(authorization string) ApiGetMUrlsByDeviceIdRequest {
	r.authorization = &authorization
	return r
}

// Return only items matching specified Management Url ID.
func (r ApiGetMUrlsByDeviceIdRequest) MurlId(murlId int32) ApiGetMUrlsByDeviceIdRequest {
	r.murlId = &murlId
	return r
}

// Limit the result set to the specified number of resources.
func (r ApiGetMUrlsByDeviceIdRequest) Limit(limit int32) ApiGetMUrlsByDeviceIdRequest {
	r.limit = &limit
	return r
}

// Skip the specified number of resources in the result set.
func (r ApiGetMUrlsByDeviceIdRequest) Offset(offset int32) ApiGetMUrlsByDeviceIdRequest {
	r.offset = &offset
	return r
}

// Must be specified if using a custom encryption key to encrypt data (found in login form).
func (r ApiGetMUrlsByDeviceIdRequest) KeyValue(keyValue string) ApiGetMUrlsByDeviceIdRequest {
	r.keyValue = &keyValue
	return r
}

func (r ApiGetMUrlsByDeviceIdRequest) Execute() (*MUrlDataWrapper, *http.Response, error) {
	return r.ApiService.GetMUrlsByDeviceIdExecute(r)
}

/*
GetMUrlsByDeviceId Fetches Management Urls by a single device id

This method fetches a single device Management Urls resource.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@return ApiGetMUrlsByDeviceIdRequest
*/
func (a *DevicesAPIService) GetMUrlsByDeviceId(ctx context.Context, deviceId int64) ApiGetMUrlsByDeviceIdRequest {
	return ApiGetMUrlsByDeviceIdRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
//
//	@return MUrlDataWrapper
func (a *DevicesAPIService) GetMUrlsByDeviceIdExecute(r ApiGetMUrlsByDeviceIdRequest) (*MUrlDataWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MUrlDataWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.GetMUrlsByDeviceId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/managementUrls/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.murlId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "murlId", r.murlId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.keyValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyValue", r.keyValue, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNotesByDeviceIdRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	deviceId      int64
	limit         *int32
	offset        *int32
	keyValue      *string
}

func (r ApiGetNotesByDeviceIdRequest) Authorization(authorization string) ApiGetNotesByDeviceIdRequest {
	r.authorization = &authorization
	return r
}

// Limit the result set to the specified number of resources.
func (r ApiGetNotesByDeviceIdRequest) Limit(limit int32) ApiGetNotesByDeviceIdRequest {
	r.limit = &limit
	return r
}

// Skip the specified number of resources in the result set.
func (r ApiGetNotesByDeviceIdRequest) Offset(offset int32) ApiGetNotesByDeviceIdRequest {
	r.offset = &offset
	return r
}

// Must be specified if using a custom encryption key to encrypt data (found in login form).
func (r ApiGetNotesByDeviceIdRequest) KeyValue(keyValue string) ApiGetNotesByDeviceIdRequest {
	r.keyValue = &keyValue
	return r
}

func (r ApiGetNotesByDeviceIdRequest) Execute() (*DeviceNoteDataWrapper, *http.Response, error) {
	return r.ApiService.GetNotesByDeviceIdExecute(r)
}

/*
GetNotesByDeviceId Fetches Notes by a single device id

This method fetches a single device Notes resource.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@return ApiGetNotesByDeviceIdRequest
*/
func (a *DevicesAPIService) GetNotesByDeviceId(ctx context.Context, deviceId int64) ApiGetNotesByDeviceIdRequest {
	return ApiGetNotesByDeviceIdRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
//
//	@return DeviceNoteDataWrapper
func (a *DevicesAPIService) GetNotesByDeviceIdExecute(r ApiGetNotesByDeviceIdRequest) (*DeviceNoteDataWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeviceNoteDataWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.GetNotesByDeviceId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.keyValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyValue", r.keyValue, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSwitchPortRangesByDeviceIdRequest struct {
	ctx               context.Context
	ApiService        *DevicesAPIService
	authorization     *string
	deviceId          int64
	switchPortRangeId *int64
	limit             *int32
	offset            *int32
	keyValue          *string
}

func (r ApiGetSwitchPortRangesByDeviceIdRequest) Authorization(authorization string) ApiGetSwitchPortRangesByDeviceIdRequest {
	r.authorization = &authorization
	return r
}

// A single device switch port range id.
func (r ApiGetSwitchPortRangesByDeviceIdRequest) SwitchPortRangeId(switchPortRangeId int64) ApiGetSwitchPortRangesByDeviceIdRequest {
	r.switchPortRangeId = &switchPortRangeId
	return r
}

// Limit the result set to the specified number of resources.
func (r ApiGetSwitchPortRangesByDeviceIdRequest) Limit(limit int32) ApiGetSwitchPortRangesByDeviceIdRequest {
	r.limit = &limit
	return r
}

// Skip the specified number of resources in the result set.
func (r ApiGetSwitchPortRangesByDeviceIdRequest) Offset(offset int32) ApiGetSwitchPortRangesByDeviceIdRequest {
	r.offset = &offset
	return r
}

// Must be specified if using a custom encryption key to encrypt data (found in login form).
func (r ApiGetSwitchPortRangesByDeviceIdRequest) KeyValue(keyValue string) ApiGetSwitchPortRangesByDeviceIdRequest {
	r.keyValue = &keyValue
	return r
}

func (r ApiGetSwitchPortRangesByDeviceIdRequest) Execute() (*SwitchPortRangeDataWrapper, *http.Response, error) {
	return r.ApiService.GetSwitchPortRangesByDeviceIdExecute(r)
}

/*
GetSwitchPortRangesByDeviceId Fetches device switch port ranges by a single device id

This method fetches a single device mapped switch port ranges resource.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@return ApiGetSwitchPortRangesByDeviceIdRequest
*/
func (a *DevicesAPIService) GetSwitchPortRangesByDeviceId(ctx context.Context, deviceId int64) ApiGetSwitchPortRangesByDeviceIdRequest {
	return ApiGetSwitchPortRangesByDeviceIdRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
//
//	@return SwitchPortRangeDataWrapper
func (a *DevicesAPIService) GetSwitchPortRangesByDeviceIdExecute(r ApiGetSwitchPortRangesByDeviceIdRequest) (*SwitchPortRangeDataWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SwitchPortRangeDataWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.GetSwitchPortRangesByDeviceId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/switchPortRanges/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.switchPortRangeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "switchPortRangeId", r.switchPortRangeId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.keyValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyValue", r.keyValue, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDeviceByIdRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	deviceId      int64
	devicePatch   *DevicePatch
}

func (r ApiUpdateDeviceByIdRequest) Authorization(authorization string) ApiUpdateDeviceByIdRequest {
	r.authorization = &authorization
	return r
}

// Device fields that need to be updated to the portal
func (r ApiUpdateDeviceByIdRequest) DevicePatch(devicePatch DevicePatch) ApiUpdateDeviceByIdRequest {
	r.devicePatch = &devicePatch
	return r
}

func (r ApiUpdateDeviceByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateDeviceByIdExecute(r)
}

/*
UpdateDeviceById Updates a single device by id

Updates specific fields on an entity (RFC 7396)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@return ApiUpdateDeviceByIdRequest
*/
func (a *DevicesAPIService) UpdateDeviceById(ctx context.Context, deviceId int64) ApiUpdateDeviceByIdRequest {
	return ApiUpdateDeviceByIdRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
func (a *DevicesAPIService) UpdateDeviceByIdExecute(r ApiUpdateDeviceByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.UpdateDeviceById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.devicePatch == nil {
		return nil, reportError("devicePatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/merge-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.devicePatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateDeviceIPByIdRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	deviceId      int64
	ipId          int64
	iPPatch       *IPPatch
}

func (r ApiUpdateDeviceIPByIdRequest) Authorization(authorization string) ApiUpdateDeviceIPByIdRequest {
	r.authorization = &authorization
	return r
}

// Device IP fields that need to be updated to the portal
func (r ApiUpdateDeviceIPByIdRequest) IPPatch(iPPatch IPPatch) ApiUpdateDeviceIPByIdRequest {
	r.iPPatch = &iPPatch
	return r
}

func (r ApiUpdateDeviceIPByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateDeviceIPByIdExecute(r)
}

/*
UpdateDeviceIPById Updates a single device IP by id

Updates specific fields on an entity (RFC 7396)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@param ipId A single device IP id.
	@return ApiUpdateDeviceIPByIdRequest
*/
func (a *DevicesAPIService) UpdateDeviceIPById(ctx context.Context, deviceId int64, ipId int64) ApiUpdateDeviceIPByIdRequest {
	return ApiUpdateDeviceIPByIdRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
		ipId:       ipId,
	}
}

// Execute executes the request
func (a *DevicesAPIService) UpdateDeviceIPByIdExecute(r ApiUpdateDeviceIPByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.UpdateDeviceIPById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/ips/{ipId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ipId"+"}", url.PathEscape(parameterValueToString(r.ipId, "ipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.iPPatch == nil {
		return nil, reportError("iPPatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/merge-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.iPPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateDeviceManagementUrlByIdRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	deviceId      int64
	murlId        int64
	mUrl          *MUrl
}

func (r ApiUpdateDeviceManagementUrlByIdRequest) Authorization(authorization string) ApiUpdateDeviceManagementUrlByIdRequest {
	r.authorization = &authorization
	return r
}

// Device Management Url fields that need to be updated to the portal
func (r ApiUpdateDeviceManagementUrlByIdRequest) MUrl(mUrl MUrl) ApiUpdateDeviceManagementUrlByIdRequest {
	r.mUrl = &mUrl
	return r
}

func (r ApiUpdateDeviceManagementUrlByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateDeviceManagementUrlByIdExecute(r)
}

/*
UpdateDeviceManagementUrlById Updates a single device Management Url by id

Updates specific fields on an entity (RFC 7396)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@param murlId A single device Management Url id.
	@return ApiUpdateDeviceManagementUrlByIdRequest
*/
func (a *DevicesAPIService) UpdateDeviceManagementUrlById(ctx context.Context, deviceId int64, murlId int64) ApiUpdateDeviceManagementUrlByIdRequest {
	return ApiUpdateDeviceManagementUrlByIdRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
		murlId:     murlId,
	}
}

// Execute executes the request
func (a *DevicesAPIService) UpdateDeviceManagementUrlByIdExecute(r ApiUpdateDeviceManagementUrlByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.UpdateDeviceManagementUrlById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/managementUrls/{murlId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"murlId"+"}", url.PathEscape(parameterValueToString(r.murlId, "murlId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.mUrl == nil {
		return nil, reportError("mUrl is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/merge-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.mUrl
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateDeviceNoteByIdRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	deviceId      int64
	noteId        int64
	deviceNote    *DeviceNote
}

func (r ApiUpdateDeviceNoteByIdRequest) Authorization(authorization string) ApiUpdateDeviceNoteByIdRequest {
	r.authorization = &authorization
	return r
}

// Device Note fields that need to be updated to the portal
func (r ApiUpdateDeviceNoteByIdRequest) DeviceNote(deviceNote DeviceNote) ApiUpdateDeviceNoteByIdRequest {
	r.deviceNote = &deviceNote
	return r
}

func (r ApiUpdateDeviceNoteByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateDeviceNoteByIdExecute(r)
}

/*
UpdateDeviceNoteById Updates a single device Note by id

Updates specific fields on an entity (RFC 7396)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@param noteId A single device Note id.
	@return ApiUpdateDeviceNoteByIdRequest
*/
func (a *DevicesAPIService) UpdateDeviceNoteById(ctx context.Context, deviceId int64, noteId int64) ApiUpdateDeviceNoteByIdRequest {
	return ApiUpdateDeviceNoteByIdRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
		noteId:     noteId,
	}
}

// Execute executes the request
func (a *DevicesAPIService) UpdateDeviceNoteByIdExecute(r ApiUpdateDeviceNoteByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.UpdateDeviceNoteById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/notes/{noteId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"noteId"+"}", url.PathEscape(parameterValueToString(r.noteId, "noteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.deviceNote == nil {
		return nil, reportError("deviceNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/merge-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.deviceNote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateSwitchPortByIdRequest struct {
	ctx               context.Context
	ApiService        *DevicesAPIService
	authorization     *string
	deviceId          int64
	switchPortRangeId int64
	switchPortId      int64
	switchPortPatch   *SwitchPortPatch
}

func (r ApiUpdateSwitchPortByIdRequest) Authorization(authorization string) ApiUpdateSwitchPortByIdRequest {
	r.authorization = &authorization
	return r
}

// Switch port fields that need to be updated to the portal
func (r ApiUpdateSwitchPortByIdRequest) SwitchPortPatch(switchPortPatch SwitchPortPatch) ApiUpdateSwitchPortByIdRequest {
	r.switchPortPatch = &switchPortPatch
	return r
}

func (r ApiUpdateSwitchPortByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSwitchPortByIdExecute(r)
}

/*
UpdateSwitchPortById Updates a single device switch port by id

Updates specific fields on an entity (RFC 7396)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@param switchPortRangeId A single device switch port range id.
	@param switchPortId A single device switch port id.
	@return ApiUpdateSwitchPortByIdRequest
*/
func (a *DevicesAPIService) UpdateSwitchPortById(ctx context.Context, deviceId int64, switchPortRangeId int64, switchPortId int64) ApiUpdateSwitchPortByIdRequest {
	return ApiUpdateSwitchPortByIdRequest{
		ApiService:        a,
		ctx:               ctx,
		deviceId:          deviceId,
		switchPortRangeId: switchPortRangeId,
		switchPortId:      switchPortId,
	}
}

// Execute executes the request
func (a *DevicesAPIService) UpdateSwitchPortByIdExecute(r ApiUpdateSwitchPortByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.UpdateSwitchPortById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/switchPortRanges/{switchPortRangeId}/switchPorts/{switchPortId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"switchPortRangeId"+"}", url.PathEscape(parameterValueToString(r.switchPortRangeId, "switchPortRangeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"switchPortId"+"}", url.PathEscape(parameterValueToString(r.switchPortId, "switchPortId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.switchPortPatch == nil {
		return nil, reportError("switchPortPatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/merge-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.switchPortPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateSwitchPortRangeByIdRequest struct {
	ctx                  context.Context
	ApiService           *DevicesAPIService
	authorization        *string
	deviceId             int64
	switchPortRangeId    int64
	switchPortRangePatch *SwitchPortRangePatch
}

func (r ApiUpdateSwitchPortRangeByIdRequest) Authorization(authorization string) ApiUpdateSwitchPortRangeByIdRequest {
	r.authorization = &authorization
	return r
}

// Switch port range fields that need to be updated to the portal
func (r ApiUpdateSwitchPortRangeByIdRequest) SwitchPortRangePatch(switchPortRangePatch SwitchPortRangePatch) ApiUpdateSwitchPortRangeByIdRequest {
	r.switchPortRangePatch = &switchPortRangePatch
	return r
}

func (r ApiUpdateSwitchPortRangeByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSwitchPortRangeByIdExecute(r)
}

/*
UpdateSwitchPortRangeById Updates a single device switch port range by id

Updates specific fields on an entity (RFC 7396)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@param switchPortRangeId A single device switch port range id.
	@return ApiUpdateSwitchPortRangeByIdRequest
*/
func (a *DevicesAPIService) UpdateSwitchPortRangeById(ctx context.Context, deviceId int64, switchPortRangeId int64) ApiUpdateSwitchPortRangeByIdRequest {
	return ApiUpdateSwitchPortRangeByIdRequest{
		ApiService:        a,
		ctx:               ctx,
		deviceId:          deviceId,
		switchPortRangeId: switchPortRangeId,
	}
}

// Execute executes the request
func (a *DevicesAPIService) UpdateSwitchPortRangeByIdExecute(r ApiUpdateSwitchPortRangeByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.UpdateSwitchPortRangeById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/switchPortRanges/{switchPortRangeId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"switchPortRangeId"+"}", url.PathEscape(parameterValueToString(r.switchPortRangeId, "switchPortRangeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.switchPortRangePatch == nil {
		return nil, reportError("switchPortRangePatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/merge-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.switchPortRangePatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUploadConfigurationToDeviceIdRequest struct {
	ctx           context.Context
	ApiService    *DevicesAPIService
	authorization *string
	deviceId      int64
	file          *os.File
	notes         *string
}

func (r ApiUploadConfigurationToDeviceIdRequest) Authorization(authorization string) ApiUploadConfigurationToDeviceIdRequest {
	r.authorization = &authorization
	return r
}

// The file to upload.
func (r ApiUploadConfigurationToDeviceIdRequest) File(file *os.File) ApiUploadConfigurationToDeviceIdRequest {
	r.file = file
	return r
}

// Notes
func (r ApiUploadConfigurationToDeviceIdRequest) Notes(notes string) ApiUploadConfigurationToDeviceIdRequest {
	r.notes = &notes
	return r
}

func (r ApiUploadConfigurationToDeviceIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.UploadConfigurationToDeviceIdExecute(r)
}

/*
UploadConfigurationToDeviceId Uploads a configuration file to Device

multipart/form-data

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId A single device id.
	@return ApiUploadConfigurationToDeviceIdRequest
*/
func (a *DevicesAPIService) UploadConfigurationToDeviceId(ctx context.Context, deviceId int64) ApiUploadConfigurationToDeviceIdRequest {
	return ApiUploadConfigurationToDeviceIdRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
func (a *DevicesAPIService) UploadConfigurationToDeviceIdExecute(r ApiUploadConfigurationToDeviceIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesAPIService.UploadConfigurationToDeviceId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/2.0/devices/{deviceId}/configurationFiles/"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.file == nil {
		return nil, reportError("file is required and must be specified")
	}

	if r.notes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notes", r.notes, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	var fileLocalVarFormFileName string
	var fileLocalVarFileName string
	var fileLocalVarFileBytes []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
